import numpy as np
from pathlib import Path


##Parameters
fold_file_path = Path('folds_trials.json')
fold_number = 0  # Definir el número de fold
fold_of_interest = str(fold_number)
data_fold = f'fold_{fold_number}'
randomize_models = False  # Si es True, se generan modelos aleatorios; si es False, se usan los modelos proporcionados
num_random_models = 2  # Número de modelos aleatorios a generar si randomize_models es True
user_model_list = np.array([1, 2])  # Lista de modelos proporcionada por el usuario
opt_for_pred_responses = False # We generate the video to match the responses generated by the original video, not the original responses.

# Generar lista de modelos
if randomize_models:
    model_list = np.random.choice(range(7), num_random_models, replace=False)
else:
    model_list = user_model_list

number_models = model_list.shape[0]
animals = range(3, 4)  # Solo incluye el índice 4
start_trial = 8  # Se refiere al índice del trial en el fold seleccionado
end_trial = 10  # No incluye este
random_trials = False  # Si es True, se eligen trials aleatorios; por defecto es False
video_length = None  # Máximo es 300, pero puede ser demasiado para algunas GPUs

check_data_fold = True
if check_data_fold: 
    if fold_number in model_list: raise ValueError("data_fold no puede ser el mismo que cualquier valor en model_list.")

proc_params = dict(
    load_skip_frames = 0,  # En caso de que se deba omitir el inicio del video; por defecto es 0
    population_reduction = 0,  # Porcentaje de neuronas a ablar/eliminar/silenciar
    pupil_position = False,
    randomize_neurons = False,  # Establecer en True para aleatorizar neuronas
    pixel_supression = 1, # Number of pixels to send to zero
)

reconstruct_params = dict(
    subbatch_size = 32,
    minibatch = 8,
    epoch_number_first = 1000,
    n_steps = 1,
    epoch_reducer = 1,
    vid_init = 'gray',
    lr = 1000,
    lr_warmup_epochs = 10,
    loss_func = 'poisson',
    use_adam = True,
    adam_beta1 = 0.9,
    adam_beta2 = 0.999,
    adam_eps = 1e-8,
    with_gradnorm = True,
    clip_grad = 1,
    pix_decay_rate = 0,
    input_noise = 0
)

eval_params = dict(
    track_iter = 10,
    plot_iter = 10,
    eval_frame_skip = 32,
)

mask_update_th = 0.5
mask_eval_th = 1

response_dropout_rate = 0
drop_method = 'zero_pred_n_true'

model_path = [None] * 7
model = [None] * number_models

model_path[0] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_0/model-000-0.290928.pth').expanduser()
model_path[1] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_1/model-000-0.292576.pth').expanduser()
model_path[2] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_2/model-000-0.291243.pth').expanduser()
model_path[3] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_3/model-000-0.290196.pth').expanduser()
model_path[4] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_4/model-000-0.289216.pth').expanduser()
model_path[5] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_5/model-000-0.288470.pth').expanduser()
model_path[6] = Path('/home/antoniofernandez/code/Sensorium/sensorium-v23.11.22/lRomul-sensorium-6849050/data/experiments/true_batch_001/fold_6/model-000-0.289128.pth').expanduser()

model_name = [None] * 7
for i in range(len(model_path)):
    model_name[i] = str(model_path[i]).split('/')[-1][:-4]

##SAVE PATH
current_dir = Path(__file__).resolve().parent